"""FastAPI application for the LVD-FV form submission and voting system."""

import asyncio
from collections.abc import AsyncGenerator
from contextlib import asynccontextmanager
from typing import Annotated

from dotenv import load_dotenv
from fastapi import Depends, FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, ConfigDict, Field
from sqlalchemy import select
from sqlalchemy.orm import Session, selectinload

from .config import Settings
from .database import engine, get_db
from .models import (
    Application,
    ApplicationStatus,
    Base,
    VoteOption,
    VoteRecord,
    VoteStatus,
)

load_dotenv()


@asynccontextmanager
async def lifespan(_app: FastAPI) -> AsyncGenerator[None, None]:
    """Handle application startup and shutdown events."""
    async with engine.begin() as conn:
        # Make sure all tables are created
        await conn.run_sync(Base.metadata.create_all)
    yield


app = FastAPI(lifespan=lifespan)

# CORS middleware setup
origins = [
    "http://localhost:5173",
    "http://127.0.0.1:5173",
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


def get_app_settings() -> Settings:
    """Return application settings."""
    settings_instance = Settings()
    if settings_instance.board_members is None:
        raise ValueError("BOARD_MEMBERS environment variable is not set.")
    return settings_instance


def get_board_members(
    settings: Annotated[Settings, Depends(get_app_settings)],
) -> list[str]:
    """Provide the list of board members from settings."""
    assert settings.board_members is not None  # Type narrowing for static analysis
    return [email.strip() for email in settings.board_members.split(",")]


# --- Pydantic Models for API data validation ---


class ApplicationCreate(BaseModel):
    """Schema for creating a new application."""

    first_name: str
    last_name: str
    applicant_email: str
    department: str
    project_title: str
    project_description: str
    costs: float


class VoteCreate(BaseModel):
    """Schema for casting a vote."""

    decision: VoteOption


class VoteOut(BaseModel):
    """Schema for displaying a vote."""

    model_config = ConfigDict(from_attributes=True)

    voter_email: str
    decision: VoteOption | None = Field(validation_alias="vote")


class ApplicationOut(BaseModel):
    """Schema for displaying an application in the archive."""

    model_config = ConfigDict(from_attributes=True)

    id: int
    first_name: str
    last_name: str
    applicant_email: str
    department: str
    project_title: str
    project_description: str
    costs: float
    status: ApplicationStatus
    votes: list[VoteOut]


# --- Email Simulation Functions ---


async def send_voting_links(
    application: Application,
    db: Session,
    board_members: list[str],
) -> None:
    """Generate vote records and simulates sending emails with unique links."""
    print("\n--- Simulating Email Notifications ---")
    for member_email in board_members:
        # Create a unique vote record for each board member
        vote_record = VoteRecord(
            application_id=application.id,
            voter_email=member_email,
        )
        db.add(vote_record)
        await db.flush()  # Flush here to get the token generated by default
        await db.refresh(
            vote_record,
        )  # Refresh to ensure the token is loaded into the object

        vote_url = f"http://localhost:5173/vote/{vote_record.token}"
        print(f"To: {member_email}")
        print(f"Subject: New Funding Application: {application.project_title}")
        print(
            f"A new application has been submitted. "
            f"Please cast your vote here: {vote_url}",
        )
        print("---")
    print("--- End of Simulation ---\n")


async def send_final_decision_emails(
    application: Application,
    board_members: list[str],
) -> None:
    """Simulate sending final decision emails to the applicant and board members."""
    print("\n--- Simulating Final Decision Emails ---")
    # Notification to Applicant
    print(f"To: {application.applicant_email}")
    print(f"Subject: Decision on your application: {application.project_title}")
    print(f"Dear {application.first_name} {application.last_name},\n")
    print(
        f"A decision has been reached. The project has been "
        f"{application.status.value.upper()}.",
    )
    print("---")

    # Notification to Board Members
    for member_email in board_members:
        print(f"To: {member_email}")
        print(f"Subject: Voting concluded for: {application.project_title}")
        print(f"The application was {application.status.value.upper()}.")
        print("---")
    print("--- End of Simulation ---\n")


async def _check_and_finalize_voting(
    application_id: int,
    db: Session,
    board_members: list[str],
) -> None:
    """Check if all votes are cast and finalize the application status."""
    application_result = await db.execute(
        select(Application)
        .where(Application.id == application_id)
        .options(selectinload(Application.votes)),
    )
    application = application_result.scalar_one()

    cast_votes = [v for v in application.votes if v.vote_status == VoteStatus.CAST]

    # If all board members have voted, determine the outcome.
    if len(cast_votes) >= len(board_members):
        approvals = sum(1 for v in cast_votes if v.vote == VoteOption.APPROVE)
        if approvals > len(board_members) / 2:
            application.status = ApplicationStatus.APPROVED
        else:
            application.status = ApplicationStatus.REJECTED

        await db.commit()
        # Schedule the email sending as a background task
        background_tasks = set()
        task = asyncio.create_task(
            send_final_decision_emails(application, board_members)
        )
        background_tasks.add(task)
        task.add_done_callback(background_tasks.discard)


# --- API Endpoints ---


@app.get("/")
async def read_root() -> dict:
    """Return a welcome message."""
    return {"message": "Welcome to the Funding Application API"}


@app.post("/applications")
async def submit_application(
    application_data: ApplicationCreate,
    db: Annotated[Session, Depends(get_db)],
    board_members: Annotated[list[str], Depends(get_board_members)],
) -> dict:
    """Create a new application and trigger the voting process."""
    new_application = Application(
        **application_data.model_dump(),
        status=ApplicationStatus.PENDING,
    )
    db.add(new_application)
    await db.flush()  # Flush to get the application ID before creating vote records
    await db.refresh(new_application)

    # Generate vote records and send links
    await send_voting_links(new_application, db, board_members)
    await db.commit()  # Commit all changes (application and vote records) here

    return {
        "message": "Application submitted successfully",
        "application_id": new_application.id,
    }


@app.get("/vote/{token}")
async def get_vote_details(token: str, db: Annotated[Session, Depends(get_db)]) -> dict:
    """Fetch application details using a secure token."""
    result = await db.execute(
        select(VoteRecord)
        .where(VoteRecord.token == token)
        .options(selectinload(VoteRecord.application)),
    )
    vote_record = result.scalar_one_or_none()

    if not vote_record:
        raise HTTPException(status_code=404, detail="Invalid or expired token.")

    if vote_record.vote_status == VoteStatus.CAST:
        raise HTTPException(status_code=400, detail="This vote has already been cast.")

    app = vote_record.application
    application_data = {
        "id": app.id,
        "project_title": app.project_title,
        "project_description": app.project_description,
        "costs": app.costs,
        "department": app.department,
    }

    return {
        "voter_email": vote_record.voter_email,
        "application": application_data,
        "vote_options": [option.value for option in VoteOption],
    }


@app.post("/vote/{token}")
async def cast_vote(
    token: str,
    vote_data: VoteCreate,
    db: Annotated[Session, Depends(get_db)],
    board_members: Annotated[list[str], Depends(get_board_members)],
) -> dict:
    """Cast a vote using a secure token and checks if voting is complete."""
    result = await db.execute(select(VoteRecord).where(VoteRecord.token == token))
    vote_record = result.scalar_one_or_none()

    if not vote_record:
        raise HTTPException(status_code=404, detail="Invalid or expired token.")

    if vote_record.vote_status == VoteStatus.CAST:
        raise HTTPException(status_code=400, detail="Vote has already been cast.")

    # Update vote record
    vote_record.vote = vote_data.decision
    vote_record.vote_status = VoteStatus.CAST
    await db.commit()

    # After a vote is cast, check if the voting process is complete.
    await _check_and_finalize_voting(
        vote_record.application_id,
        db,
        board_members,
    )

    return {"message": "Vote cast successfully"}


@app.get("/applications/archive", response_model=list[ApplicationOut])
async def get_applications_archive(
    db: Annotated[Session, Depends(get_db)],
) -> list[ApplicationOut]:
    """Return a list of all applications with their current status and votes."""
    result = await db.execute(
        select(Application)
        .options(selectinload(Application.votes))
        .order_by(Application.id.desc()),
    )
    applications = result.scalars().unique().all()

    return [ApplicationOut.model_validate(app) for app in applications]
