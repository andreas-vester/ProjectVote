import asyncio
from contextlib import asynccontextmanager
from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy.orm import Session, selectinload
from sqlalchemy import select
from pydantic import BaseModel

from .database import engine, get_db
from .models import (
    Application,
    VoteRecord,
    VoteOption,
    ApplicationStatus,
    VoteStatus,
    Base,
)
from fastapi.middleware.cors import CORSMiddleware


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Handles application startup and shutdown events."""
    async with engine.begin() as conn:
        # Make sure all tables are created
        await conn.run_sync(Base.metadata.create_all)
    yield


app = FastAPI(lifespan=lifespan)

# CORS middleware setup
origins = [
    "http://localhost:5173",
    "http://127.0.0.1:5173",
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# In a real application, this might come from a config file or user database
BOARD_MEMBERS = [
    "board.member1@example.com",
    "board.member2@example.com",
    "board.member3@example.com",
]

# --- Pydantic Models for API data validation ---


class ApplicationCreate(BaseModel):
    first_name: str
    last_name: str
    applicant_email: str
    department: str
    project_title: str
    project_description: str
    costs: float


class VoteCreate(BaseModel):
    decision: VoteOption


# --- Email Simulation Functions ---


async def send_voting_links(application: Application, db: Session):
    """Generates vote records and simulates sending emails with unique links."""
    print("\n--- Simulating Email Notifications ---")
    for member_email in BOARD_MEMBERS:
        # Create a unique vote record for each board member
        vote_record = VoteRecord(
            application_id=application.id,
            voter_email=member_email,
        )
        db.add(vote_record)
        await db.flush()  # Flush here to get the token generated by default
        await db.refresh(
            vote_record
        )  # Refresh to ensure the token is loaded into the object

        vote_url = f"http://localhost:5173/vote/{vote_record.token}"
        print(f"To: {member_email}")
        print(f"Subject: New Funding Application: {application.project_title}")
        print(
            f"A new application has been submitted. Please cast your vote here: {vote_url}"
        )
        print("---")
    print("--- End of Simulation ---\n")


async def send_final_decision_emails(application: Application, db: Session):
    """Simulates sending final decision emails to the applicant and board members."""
    print("\n--- Simulating Final Decision Emails ---")
    # Notification to Applicant
    print(f"To: {application.applicant_email}")
    print(f"Subject: Decision on your application: {application.project_title}")
    print(f"Dear {application.first_name} {application.last_name},\n")
    print(
        f"A decision has been reached. The project has been {application.status.value.upper()}."
    )
    print("---")

    # Notification to Board Members
    for member_email in BOARD_MEMBERS:
        print(f"To: {member_email}")
        print(f"Subject: Voting concluded for: {application.project_title}")
        print(f"The application was {application.status.value.upper()}.")
        print("---")
    print("--- End of Simulation ---\n")


# --- API Endpoints ---


@app.get("/", response_model=dict)
async def read_root():
    return {"message": "Welcome to the Funding Application API"}


@app.post("/applications", response_model=dict)
async def submit_application(
    application_data: ApplicationCreate, db: Session = Depends(get_db)
):
    """Creates a new application and triggers the voting process."""
    new_application = Application(
        **application_data.model_dump(), status=ApplicationStatus.PENDING
    )
    db.add(new_application)
    await db.flush()  # Flush to get the application ID before creating vote records
    await db.refresh(new_application)

    # Generate vote records and send links
    await send_voting_links(new_application, db)
    await db.commit()  # Commit all changes (application and vote records) here

    return {
        "message": "Application submitted successfully",
        "application_id": new_application.id,
    }


@app.get("/vote/{token}", response_model=dict)
async def get_vote_details(token: str, db: Session = Depends(get_db)):
    """Fetches application details using a secure token."""
    result = await db.execute(
        select(VoteRecord)
        .where(VoteRecord.token == token)
        .options(selectinload(VoteRecord.application))
    )
    vote_record = result.scalar_one_or_none()

    if not vote_record:
        raise HTTPException(status_code=404, detail="Invalid or expired token.")

    if vote_record.vote_status == VoteStatus.CAST:
        raise HTTPException(status_code=400, detail="This vote has already been cast.")

    app = vote_record.application
    application_data = {
        "id": app.id,
        "project_title": app.project_title,
        "project_description": app.project_description,
        "costs": app.costs,
        "department": app.department,
    }

    return {
        "voter_email": vote_record.voter_email,
        "application": application_data,
        "vote_options": [option.value for option in VoteOption],
    }


@app.post("/vote/{token}", response_model=dict)
async def cast_vote(token: str, vote_data: VoteCreate, db: Session = Depends(get_db)):
    """Casts a vote using a secure token and checks if voting is complete."""
    result = await db.execute(select(VoteRecord).where(VoteRecord.token == token))
    vote_record = result.scalar_one_or_none()

    if not vote_record:
        raise HTTPException(status_code=404, detail="Invalid or expired token.")

    if vote_record.vote_status == VoteStatus.CAST:
        raise HTTPException(status_code=400, detail="Vote has already been cast.")

    # Update vote record
    vote_record.vote = vote_data.decision
    vote_record.vote_status = VoteStatus.CAST
    await db.commit()

    # Check if voting is complete
    application_result = await db.execute(
        select(Application)
        .where(Application.id == vote_record.application_id)
        .options(selectinload(Application.votes))
    )
    application = application_result.scalar_one()

    cast_votes = [v for v in application.votes if v.vote_status == VoteStatus.CAST]

    if len(cast_votes) >= len(BOARD_MEMBERS):
        approvals = sum(1 for v in cast_votes if v.vote == VoteOption.APPROVE)
        if approvals > len(BOARD_MEMBERS) / 2:
            application.status = ApplicationStatus.APPROVED
        else:
            application.status = ApplicationStatus.REJECTED

        await db.commit()
        asyncio.create_task(send_final_decision_emails(application, db))

    return {"message": "Vote cast successfully"}


@app.get("/applications", response_model=list)
async def view_applications(db: Session = Depends(get_db)):
    """Returns a list of all applications with their current status and votes."""
    result = await db.execute(
        select(Application)
        .options(selectinload(Application.votes))
        .order_by(Application.id.desc())
    )
    applications = result.scalars().unique().all()

    applications_data = []
    for app in applications:
        app_data = {
            "id": app.id,
            "first_name": app.first_name,
            "last_name": app.last_name,
            "applicant_email": app.applicant_email,
            "department": app.department,
            "project_title": app.project_title,
            "project_description": app.project_description,
            "costs": app.costs,
            "status": app.status.value,
            "votes": [
                {
                    "voter_email": v.voter_email,
                    "decision": v.vote.value if v.vote else None,
                }
                for v in app.votes
            ],
        }
        applications_data.append(app_data)

    return applications_data
